import httpx
import base64
import json
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

router = APIRouter()

class RoadmapRequest(BaseModel):
    current_skills: str
    goal: str
    language: str

@router.post("/roadmap")
async def generate_roadmap(request: RoadmapRequest):
    """
    Generate a personalized career roadmap using the external AI service.
    Proxies the request to n8n webhook with secure credentials.
    """
    # Hardcoded credentials as per instructions (in production, use env vars)
    username = "Gyanify"
    password = "Gyanify123"
    
    # Create Basic Auth header
    auth_string = f"{username}:{password}"
    auth_bytes = auth_string.encode('ascii')
    base64_bytes = base64.b64encode(auth_bytes)
    base64_auth = base64_bytes.decode('ascii')
    
    url = "https://zaiddd.app.n8n.cloud/webhook/8be78b34-dbc8-418a-83b0-044991ac14c2"
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Basic {base64_auth}"
    }
    
    payload = {
        "current-skills": request.current_skills,
        "goal": request.goal,
        "language": request.language
    }
    
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(url, json=payload, headers=headers, timeout=60.0)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            raise HTTPException(status_code=e.response.status_code, detail=f"AI Service Error: {e.response.text}")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Internal Server Error: {str(e)}")

class PodcastRequest(BaseModel):
    text: str
    language: str = "english"
    title: str = "Generated Podcast"  # Added title for history

from app.api.deps import get_current_user
from app.db.supabase_client import supabase
from app.models.podcast import PodcastResponse
from typing import List
from datetime import datetime
import uuid

@router.post("/generate-podcast")
async def generate_podcast(
    request: PodcastRequest,
    current_user: dict = Depends(get_current_user)
):
    """
    Generate a podcast from text using the Localizer service and save to history.
    """
    try:
        # 1. Call Localizer Service
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:8001/podcast/generate",
                data={"text": request.text, "language": request.language},
                timeout=300.0
            )
            response.raise_for_status()
            result = response.json()
            
        audio_url = result.get("audio_url")
        
        # 2. Save to Supabase History (if audio generated)
        if audio_url:
            podcast_data = {
                "id": str(uuid.uuid4()),
                "user_id": current_user["id"],
                "title": request.title,
                "description": request.text[:200] + "...",
                "language": request.language,
                "audio_url": audio_url,
                "created_at": datetime.utcnow().isoformat()
            }
            try:
                supabase.table("podcasts").insert(podcast_data).execute()
            except Exception as e:
                print(f"⚠️ Failed to save podcast history: {e}")
                # Don't fail the request if history save fails, just return the audio
        
        return result
            
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=f"Podcast Service Error: {e.response.text}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal Server Error: {str(e)}")

@router.get("/my-podcasts", response_model=List[PodcastResponse])
async def get_my_podcasts(current_user: dict = Depends(get_current_user)):
    """Fetch all podcasts generated by the current user."""
    try:
        response = supabase.table("podcasts").select("*").eq("user_id", current_user["id"]).order("created_at", desc=True).execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch podcasts: {str(e)}")
